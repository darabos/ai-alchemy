<html>
<script type="importmap">
{ "imports": { "vue": "/vue.js" } }
</script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Neuton:wght@400&display=swap');

  html {
    background: linear-gradient(to bottom, #fed, #abc);
    font-family: 'Neuton', serif;
  }
  .footer {
    margin-top: 50px;
  }
  .card-list {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
  }
  @property --cycledColor {
    syntax: "<color>";
    inherits: false;
    initial-value: #fff;
  }
  .card-slot {
    display: flex;
    flex-direction: column;
    justify-content: end;
    width: 200px;
    height: 240px;
    margin: 20px;
    margin-top: 0;
  }
  .footer,
  .card-header {
    color: #0008;
    letter-spacing: 2;
    font-size: 12px;
  }
  .card-header {
    margin-bottom: 5px;
    display: flex;
    justify-content: end;
    align-items: end;
  }
  .card-origin {
    flex: 1;
  }
  .card-slot .card-button {
    visibility: hidden;
  }
  .card-slot:hover .card-button {
    visibility: visible;
  }
  .card-button:hover {
    cursor: pointer;
    color: black;
  }
  .card {
    width: 200px;
    height: 200px;
    position: relative;
    overflow: hidden;
    border-radius: 10px;
    transition: box-shadow 0.5s;
    background: radial-gradient(circle, var(--cycledColor), #0000 70%);
    animation: 1s infinite colorCycle;
  }
  @keyframes colorCycle {
    from { --cycledColor: #a7770c; }
    10% { --cycledColor: #c75d36; }
    20% { --cycledColor: #dc3b6d; }
    30% { --cycledColor: #d826b8; }
    40% { --cycledColor: #b54bec; }
    50% { --cycledColor: #7d72f0; }
    60% { --cycledColor: #3a8bca; }
    70% { --cycledColor: #169596; }
    80% { --cycledColor: #199a5d; }
    90% { --cycledColor: #718e13; }
    to { --cycledColor: #a7770c; }
  }
  .card.loaded {
    background: none;
    box-shadow: 0 5px 10px black;
  }
  .card.loaded img {
    opacity: 1;
  }
  .card img {
    opacity: 0;
    transition: opacity 0.5s;
    -webkit-user-drag: none;
    width: 200px;
    height: 200px;
  }
  .card .title {
    position: absolute;
    bottom: 10%;
    left: 10%;
    width: 80%;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 28px;
    /* font-weight: bold; */
    color: white;
    text-shadow: 0 0 4px black, 0 2px 4px black;
  }
  .unlock-hint {
    margin: 5px;
  }
</style>
<div id="app"></div>
<script type="module">
  import { computed, createApp, ref, watch } from 'vue';
  const app = createApp({
    setup() {
      const { data, error } = useFetch('/info');
      const redraws = ref({});
      const that = {
        info: data, error, redraws,
        async mergeCards({ a, b }) {
          const res = await fetch(`/merge?a=${a}&b=${b}`)
          const j = await res.json();
          data.value.merges[a + ' + ' + b] = j.merged;
        },
        forgetCard(card) {
          for (const k in data.value.merges) {
            if (k === card.origin) {
              delete data.value.merges[k];
            }
          }
          const [a, b] = card.origin.split(' + ');
          return fetch('/forget?' + new URLSearchParams({a, b, card: card.name}), { method: 'POST' });
        },
        async rerollCard(card) {
          const [a, b] = card.origin.split(' + ');
          await that.forgetCard(card);
          await that.mergeCards({ a, b });
        },
        async redrawCard(card) {
          await fetch(`/redraw?card=${card.name}`, { method: 'POST' });
          redraws.value[card.name] = (new Date()).getTime();
        },
        cards: computed(() => {
          if (!data.value) return [];
          const cards = [];
          for (const k of data.value.base_cards) {
            cards.push({
              name: k,
              origin: 'Fundamental',
              key: k + cards.length,
            });
          }
          for (const k in data.value.merges) {
            const name = data.value.merges[k];
            cards.push({
              name,
              origin: k,
              key: k + cards.length,
            });
            const unlocked = data.value.unlocks[name];
            if (unlocked) {
              cards.push({
                name: unlocked,
                origin: `Unlocked by ${name}`,
                key: unlocked + cards.length,
              });
            }
          }
          return cards;
        }),
        unmetUnlocks: computed(() => {
          if (!data.value) return [];
          const generated = {};
          for (const c of Object.values(data.value.merges)) {
            generated[c] = true;
          }
          return Object.keys(data.value.unlocks).filter((k) => !generated[k]);
        }),
      };
      return that;
    },
    template: `
      <div class="card-list">
        <p v-if="error">Error: {{ error }}</p>
        <Card
          v-for="c in cards"
          :key="c.key"
          :card="c"
          :redraw="redraws[c.name]"
          @merge-cards="mergeCards"
          @forget-card="forgetCard"
          @redraw-card="redrawCard"
          @reroll-card="rerollCard"
        />
      </div>
      <div class="footer">
        Remaining unlocks: <span class="unlock-hint" v-for="u in unmetUnlocks">{{ u }}</span>
      </div>
    `
  });
  app.component('Card', {
    props: ['card', 'redraw'],
    emits: ['merge-cards', 'forget-card', 'redraw-card', 'reroll-card'],
    setup(props, ctx) {
      const isLoaded = ref(false);
      return {
        isLoaded,
        title: props.card.name,
        imageUrl: computed(() => {
          const base = `/image/${props.card.name}`;
          if (props.redraw) {
            return `${base}?${props.redraw}`;
          }
          return base;
        }),
        startDrag(evt, item) {
          evt.target.style.visible = 'hidden';
          evt.dataTransfer.dropEffect = 'link';
          evt.dataTransfer.setData("text/plain", props.card.name);
        },
        onDrop(evt, list) {
          evt.preventDefault();
          const a = props.card.name;
          const b = evt.dataTransfer.getData('text/plain');
          ctx.emit('merge-cards', { a, b });
        },
        loaded() {
          isLoaded.value = true;
        },
        rerollCard() {
          ctx.emit('reroll-card', props.card);
        },
        forgetCard() {
          ctx.emit('forget-card', props.card);
        },
        redrawCard() {
          isLoaded.value = false;
          ctx.emit('redraw-card', props.card);
        },
      };
    },
    template: `
      <div class="card-slot">
        <div class="card-header">
          <span class="card-origin">{{ card.origin }}</span>
          <span class="card-button" title="Try again" @click="rerollCard">ðŸŽ²</span>
          <span class="card-button" title="Forget" @click="forgetCard">ðŸ—‘</span>
          <span class="card-button" title="Redraw" @click="redrawCard">âœŽ</span>
        </div>
        <div class="card"
            :class="{ 'loaded': isLoaded }"
            @dragstart="startDrag"
            @dragenter.prevent
            @dragover.prevent
            @drop="onDrop"
            draggable="true">
          <img :src="imageUrl" :title="title" @load="loaded">
          <div class="title">{{ title }}</div>
        </div>
      </div>
    `,
  });
  app.mount('#app');

  function useFetch(url) {
    const data = ref(null)
    const error = ref(null)
    fetch(url)
    .then((res) => res.json())
    .then((json) => (data.value = json))
    .catch((err) => (error.value = err))
    return { data, error }
  }
  </script>
</html>
